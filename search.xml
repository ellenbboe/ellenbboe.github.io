<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux From Scrach Pass 2]]></title>
    <url>%2F2018%2F07%2F14%2Flfs2%2F</url>
    <content type="text"><![CDATA[编译临时工具软件包过程说明:主要列出重要信息(来自官方),切忌不要按照本文编译我只是把它们列出来加深理解,还有一些配置我没有列出包括make与make install Binutils-2.25 - Pass 1Binutils 软件包包括了一个链接器、汇编器 和 其它处理目标文件 的工具。 1234567../binutils-2.25/configure \ --prefix=/tools \ --with-sysroot=$LFS \ --with-lib-path=/tools/lib \ --target=$LFS_TGT \ --disable-nls \ --disable-werror 配置选项的含义： --prefix=/tools 告诉配置脚本将 Binutils 程序安装到 /tools 文件夹。 --with-sysroot=$LFS 用于交叉编译，告诉编译系统在 $LFS 中查找所需的目标系统库。 --with-lib-path=/tools/lib 指定需要配置使用的链接器的库路径。 --target=$LFS_TGT (这个还不是很清楚) 因为 LFS_TGT 变量中的机器描述和 config.guess 脚本返回的值略有不同，这个选项会告诉 configure 脚本调整 Binutils 的编译系统来编译一个交叉链接器。 --disable-nls 这会禁止国际化（i18n），因为国际化对临时工具来说没有必要。 --disable-werror 这会防止来自宿主编译器的警告事件导致停止编译。 GCC-7.3.0 - Pass 1GCC 软件包是 GNU 编译器 集合的一部分，其中包括 C 和 C++ 的编译器。 下面的指令将会修改 GCC 默认的动态链接器为安装在 /tools 文件夹中的。它也会从 GCC 的 include 搜索路径中移除 /usr/include 12345678910111213for file in \ $(find gcc/config -name linux64.h -o -name linux.h -o -name sysv4.h)do cp -uv $file&#123;,.orig&#125; sed -e &apos;s@/lib\(64\)\?\(32\)\?/ld@/tools&amp;@g&apos; \ -e &apos;s@/usr@/tools@g&apos; $file.orig &gt; $file echo &apos;#undef STANDARD_STARTFILE_PREFIX_1#undef STANDARD_STARTFILE_PREFIX_2#define STANDARD_STARTFILE_PREFIX_1 &quot;/tools/lib/&quot;#define STANDARD_STARTFILE_PREFIX_2 &quot;&quot;&apos; &gt;&gt; $file touch $file.origdone 如果上面的看起来难以理解，让我们分开来看一下吧。首先我们找到 gcc/config 文件夹下的所有命名为 linux.h, linux64.h 或sysv4.h 的文件。对于找到的每个文件，我们把它复制到相同名称的文件，但增加了后缀 “.orig”。然后第一个 sed 表达式在每个 “/lib/ld”, “/lib64/ld” 或 “/lib32/ld” 实例前面增加“/tools”，第二个 sed 表达式替换 “/usr” 的硬编码实例。然后，我们添加这改变默认 startfile 前缀到文件末尾的定义语句。注意 “/tools/lib/” 后面的 “/” 是必须的。最后，我们用 touch 更新复制文件的时间戳。当与 cp -u 一起使用时，可以防止命令被无意中运行两次造成对原始文件意外的更改。(厉害厉害) 8.2版本中不用以下命令(可能修复了这个错误):12GCC 不能正确检测栈保护，这会导致编译 Glibc-2.21 时出现问题，用下面的命令修复这个问题：sed -i &apos;/k prot/agcc_cv_libc_provides_ssp=yes&apos; gcc/configure 准备编译 GCC:1234567891011121314151617181920212223../gcc-4.9.2/configure \ --target=$LFS_TGT \ --prefix=/tools \ --with-sysroot=$LFS \ --with-newlib \ --without-headers \ --with-local-prefix=/tools \ --with-native-system-header-dir=/tools/include \ --disable-nls \ --disable-shared \ --disable-multilib \ --disable-decimal-float \ --disable-threads \ --disable-libatomic \ --disable-libgomp \ --disable-libitm \ --disable-libquadmath \ --disable-libsanitizer \ --disable-libssp \ --disable-libvtv \ --disable-libcilkrts \ --disable-libstdc++-v3 \ --enable-languages=c,c++ --with-newlib由于还没有可用的 C 库，这确保编译 libgcc 时定义了常数 inhibit_libc。这可以防止编译任何需要 libc 支持的代码。 --without-headers创建一个完成的交叉编译器的时候，GCC 要求标准头文件和目标系统兼容。对于我们的目的来说，不需要这些头文件。这个选项可以防止 GCC 查找它们。 --with-local-prefix=/toolsGCC 会查找本地已安装的 include 文件的系统位置。默认是 /usr/local。把它设置为 /tools 能把主机位置中的 /usr/local 从 GCC 的搜索路径中排除。 --with-native-system-header-dir=/tools/includeGCC 默认会在/usr/include 中查找系统头文件。和 sysroot 选项一起使用，会转换为 $LFS/usr/include。在后面两个章节中头文件会被安装到 $LFS/tools/include。这个选项确保 gcc 能正确找到它们。第二次编译 GCC 时，同样的选项可以保证不会去寻找主机系统的头文件。 --disable-shared这个选项强制 GCC 静态链接到它的内部库。我们这样做是为了避免与主机系统可能出现的问题。 --disable-decimal-float, --disable-threads, --disable-libatomic, --disable-libgomp, --disable-libitm, --disable-libquadmath, --disable-libsanitizer, --disable-libssp, --disable-libvtv, --disable-libcilkrts, --disable-libstdc++-v3这些选项取消了对十进制浮点数扩展、线程化、libatomic、 libgomp、 libitm、 libquadmath、 libsanitizer、 libssp、 libvtv、 libcilkrts 和 C++ 标准库的支持。这些功能在编译交叉编译器的时候会导致编译失败，对于交叉编译 临时 libc 来说也没有必要。 –disable-multilib在 x86_64 机器上， LFS 还不支持 multilib 配置。这个选项对 x86 来说无害。 –enable-languages=c,c++这个选项确保只编译 C 和 C++ 编译器。这些是现在唯一需要的语言。 Linux-4.15.3 API Headers供系统 C 库（在 LFS 中是 Glibc）使用的应用程序编程接口（API） Glibc-2.27Glibc 软件包包括主要的 C 库。这个库提供了基本的内存分配、文件夹搜素、读写文件、字符串处理、模式匹配、算术 等等例程。 编译:12345678910../glibc-2.21/configure \ --prefix=/tools \ --host=$LFS_TGT \ --build=$(../glibc-2.21/scripts/config.guess) \ --disable-profile \ --enable-kernel=2.6.32 \ --with-headers=/tools/include \ libc_cv_forced_unwind=yes \ libc_cv_ctors_header=yes \ libc_cv_c_cleanup=yes --host=$LFS_TGT, --build=$(../glibc-2.21/scripts/config.guess)这些选项的组合效果是 Glibc 的构建系统配置它自己用 /tools 里面的交叉链接器和交叉编译器交叉编译自己。 --disable-profile编译库但不包含分析信息。如果临时工具需要分析信息则忽略此选项。 --enable-kernel=3.2这告诉 Glibc 编译能支持 Linux 3.2 以及之后的内核库。更早的内核版本不受支持。 --with-headers=/tools/include告诉 Glibc 利用刚刚安装在 tools 文件夹中的头文件编译自身，此能够根据内核的具体特性提供更好的优化。 libc_cv_forced_unwind=yes在 “Binutils-2.25 - Pass 1” 中安装的链接器是交叉编译的，在安装完 Glibc 之前不能使用。由于依赖于工作的链接器，这意味着 force-unwind 支持的配置测试会失败。将 libccvforced_unwind=yes 变量传递进去告诉configure 命令 force-unwind 支持是可用的，不需要进行测试。 libc_cv_c_cleanup=yes类似的，我们传递 libc_cv_c_cleanup=yes 到 configure 脚本跳过测试就完成了 C 清理支持的配置。 libc_cv_ctors_header=yes类似的，我们传递 libc_cv_ctors_header=yes 到 configure 脚本跳过测试就完成了 gcc 构建器支持的配置。 Libstdc++-7.3.0Libstdc++ 是标准的 C++ 库。g++ 编译器正确运行需要它。Libstdc++ 是标准的 C++ 库。g++ 编译器正确运行需要它。 编译:123456789../gcc-4.9.2/libstdc++-v3/configure \ --host=$LFS_TGT \ --prefix=/tools \ --disable-multilib \ --disable-shared \ --disable-nls \ --disable-libstdcxx-threads \ --disable-libstdcxx-pch \ --with-gxx-include-dir=/tools/$LFS_TGT/include/c++/4.9.2 –host=…指示使用我们刚才编译的交叉编译器，而不是 /usr/bin 中的。 –disable-libstdcxx-threads由于我们还没有编译 C 线程库，C++ 的也还不能编译。 –disable-libstdcxx-pch此选项防止安装预编译文件，此步骤并不需要。 –with-gxx-include-dir=/tools/$LFS_TGT/include/c++/7.3.0这是 C++ 编译器搜索标准 include 文件的位置。在一般的编译中，这个信息自动从顶层文件夹中传入 Libstdc++ configure 选项。在我们的例子中，必须明确给出这信息。 Binutils-2.30 - Pass 2编译:123456789CC=$LFS_TGT-gcc \AR=$LFS_TGT-ar \RANLIB=$LFS_TGT-ranlib \../binutils-2.25/configure \ --prefix=/tools \ --disable-nls \ --disable-werror \ --with-lib-path=/tools/lib \ --with-sysroot CC=$LFS_TGT-gcc AR=$LFS_TGT-ar RANLIB=$LFS_TGT-ranlib因为这是真正的原生编译 Binutils，设置这些变量能确保编译系统使用交叉编译器和相关的工具，而不是宿主系统中已有的。 --with-lib-path=/tools/lib这告诉配置脚本在编译 Binutils 的时候指定库搜索目录，此处将 /tools/lib 传递到链接器。这可以防止链接器搜索宿主系统的库目录。 --with-sysrootsysroot 功能使链接器可以找到包括在其命令行中的其它共享对象明确需要的共享对象。 否则的话，在某些主机上一些软件包可能会编译不成功。(….未理解) 为下一章的“再调整”阶段准备链接器：123make -C ld cleanmake -C ld LIB_PATH=/usr/lib:/libcp -v ld/ld-new /tools/bin -C ld clean告诉 make 程序移除所有 ld 子目录中编译过的文件。 -C ld LIB_PATH=/usr/lib:/lib这个选项重新编译 ld 子目录中的所有文件。在命令行中指定 Makefile 的 LIB_PATH 变量可以使我们能够重写临时工具的默认值并指向正确的最终路径。该变量的值指定链接器的默认库搜索路径。 下一章中会用到这个准备。 GCC-7.3.0 - Pass 2我们第一次编译 GCC 的时候安装了一些内部系统头文件。其中的一个 limits.h 会反过来包括对应的系统头文件 limits.h， 在我们的例子中，是 /tools/include/limits.h。但是，第一次编译 gcc 的时候 /tools/include/limits.h 并不存在，因此 GCC 安装的内部头文件只是部分的自包含文件， 并不包括系统头文件的扩展功能。这足以编译临时 libc，但是这次编译 GCC 要求完整的内部头文件。 使用和正常情况下 GCC 编译系统使用的相同的命令创建一个完整版本的内部头文件： 12cat gcc/limitx.h gcc/glimits.h gcc/limity.h &gt; \ `dirname $($LFS_TGT-gcc -print-libgcc-file-name)`/include-fixed/limits.h 准备编译 GCC:12345678910111213CC=$LFS_TGT-gcc \CXX=$LFS_TGT-g++ \AR=$LFS_TGT-ar \RANLIB=$LFS_TGT-ranlib \../gcc-4.9.2/configure \ --prefix=/tools \ --with-local-prefix=/tools \ --with-native-system-header-dir=/tools/include \ --enable-languages=c,c++ \ --disable-libstdcxx-pch \ --disable-multilib \ --disable-bootstrap \ --disable-libgomp --enable-languages=c,c++这个选项确保编译了 C 和 C++ 编译器。 --disable-libstdcxx-pch不为 libstdc++ 编译预编译的头文件(PCH)。这会花费很多时间，却对我们没有用处。 --disable-bootstrap对于原生编译的 GCC，默认是做一个“引导”构建。这不仅会编译 GCC，而且会多次编译。 它用第一次编译的程序去第二次编译自己，然后同样进行第三次。 比较第二次和第三次迭代确保它可以完美复制自身。这也意味着已经成功编译。 但是，LFS 的构建方法能够提供一个稳定的编译器，而不需要每次都重新引导。 Tcl-core-8.6.8Tcl软件包包含工具命令语言（Tool Command Language）相关程序。 此软件包和后面三个包（Expect、DejaGNU 和 Check）用来为 GCC 和 Binutils还有其他的一些软件包的测试套件提供运行支持。仅仅为了测试目的而安装 4 个软件包，看上去有点奢侈，虽然因为大部分重要的工具都能正常工作而并不需要去做测试。 尽管在本章中并没有执行测试套件（并不做要求），但是在第六章 中都要求执行这些软件包自带的测试套件。不强求为本章中所构建的临时工具运行测试套件。 Expect-5.45Expect 软件包包含一个实现用脚本和其他交互式程序进行对话的程序。 首先，强制 Expect 的 configure 配置脚本使用 /bin/stty 替代宿主机系统里可能存在的 /usr/local/bin/stty。这样可以保证我们的测试套件工具在工具链的最后一次构建能够正常。12cp -v configure&#123;,.orig&#125;sed &apos;s:/usr/local/bin:/bin:&apos; configure.orig &gt; configure 编译:123./configure --prefix=/tools \ --with-tcl=/tools/lib \ --with-tclinclude=/tools/include --with-tcl=/tools/lib这个选项可以保证 configure 配置脚本会从临时工具目录里找 Tcl 的安装位置， 而不是在宿主机系统中寻找。 --with-tclinclude=/tools/include这个选项会给 Expect 显式地指定 Tcl 内部头文件的位置。通过这个选项可以避免 configure 脚本不能自动发现 Tcl 头文件位置的情况。 DejaGNU-1.6.1./configure --prefix=/tools M4-1.4.18M4 软件包包含一个宏预处理器。./configure --prefix=/tools Ncurses-6.1123456./configure --prefix=/tools \ --with-shared \ --without-debug \ --without-ada \ --enable-widec \ --enable-overwrite --without-ada这个选项会保证 Ncurse 不会编译对宿主机系统里可能存在的 Ada 编译器的支持， 而这在我们 chroot 切换环境后就不再可用。 --enable-overwrite这个选项会告诉 Ncurses 安装它的头文件到 /tools/include 目录， 而不是 /tools/include/ncurses 目录， 保证其他软件包可以正常找到 Ncurses 的头文件。 --enable-widec这个选项会控制编译宽字符库（比如，libncursesw.so.5.9） 而不是默认的普通库（比如，libncurses.so.5.9）。 这些宽字符库在多字节和传统的 8 位环境下使用，而普通库只能用于 8 位环境。 宽字符库和普通库的源代码是兼容的，但并不是二进制兼容。 Bash-4.4.18Bash 软件包包含 Bourne-Again SHell 终端程序编译:1./configure --prefix=/tools --without-bash-malloc --without-bash-malloc这个选项会禁用 Bash 的内存分配功能（malloc）， 这个功能已知会导致段错误。而禁用这个功能后，Bash 将使用 Glibc 的 malloc 函数，这样会更稳定。 Bison-3.0.4The Bison package contains a parser generator.(解析器生成器) Bzip2-1.0.6Bzip2 软件包包含压缩和解压文件的工具。 用 bzip2 压缩文本文件比传统的 gzip 压缩比高得多。 Coreutils-8.29Coreutils 软件包包含一套用于显示和设定基本系统属性的工具。12./configure --prefix=/tools --enable-install-program=hostname--enable-install-program=hostname 这个选项会允许编译和安装 hostname 程序 – 默认是不安装的但是 Perl 测试套件需要它。 Diffutils-3.6Diffutils软件包包含用来比较文件或目录之间差异的工具。 File-5.32File 软件包包含用来判断文件类型的工具。 Findutils-4.6.0Findutils 软件包包含用来查找文件的工具。这些工具可以用来在目录树中递归查找，或者创建、维护和搜索数据库（一般会比递归查找快，但是如果不经常更新数据库的话结果不可靠）。 Gawk-4.2.0Gawk 软件包包含处理文本文件的工具。 Gettext-0.19.8.1Gettext 软件包包含了国际化和本地化的相关应用。它支持程序使用 NLS（本地语言支持）编译，允许程序用用户本地语言输出信息。12cd gettext-toolsEMACS=&quot;no&quot; ./configure --prefix=/tools --disable-shared EMACS=&quot;no&quot;这个选项会禁止配置脚本侦测安装 Emacs Lisp 文件的位置，已知在某些系统中会引起错误。 --disable-shared这次我们不需要安装任何的 Gettext 动态库，所以不需要编译。 Grep-3.1Grep 软件包包含了在文件中搜索的工具。 Gzip-1.9Gzip 软件包包含压缩和解压缩文件的工具。 Make-4.2.1Make 软件包包含了一个用来编译软件包的程序。12./configure --prefix=/tools --without-guile--without-guile 这个选项会保证 Make 不会链接宿主系统上可能存在的 Guile 库，而在下一章里通过 chroot 切换环境后就不再可用 Patch-2.7.6Patch 软件包包含一个可以通过应用“补丁”文件来修改或创建文件的程序，补丁文件通常由diff程序生成。 Perl-5.26.1Perl 软件包包含了处理实用报表提取语言（Practical Extraction and Report Language）的程序。 Sed-4.4Sed 软件包包含一个字符流编辑器。 Tar-1.30Tar 软件包包含了一个存档工具。 Texinfo-6.5Texinfo软件包包含了读写和转换info文档的工具。 Util-linux-2.31.1Util-linux 软件包包含了各种各样的小工具。12345./configure --prefix=/tools \ --without-python \ --disable-makeinstall-chown \ --without-systemdsystemunitdir \ PKG_CONFIG=&quot;&quot; --without-python这个选项会禁止使用宿主系统中可能安装了的 Python。这样可以避免构建一些不必要的捆绑应用。 --disable-makeinstall-chown这个选项会禁止在安装的时候使用 chown 命令。这对我们安装到 /tools 目录没有意义而且可以避免使用 root 用户安装。 --without-systemdsystemunitdir对于使用 systemd 的系统，这个软件包会尝试安装 systemd 特定文件到 /tools 下一个不存在的目录里。这个选项可以避免这个不必要的动作。 PKG_CONFIG=&quot;&quot;设定这个环境变量可以避免增加一些宿主机上存在却不必要的功能。请注意这里设定环境变量的方式和 LFS 其他部分放在命令前面的方式不同。在这里是为了展示一下使用 configure 脚本配置时设定环境变量的另一种方式。 Xz-5.2.3Xz 软件包包含了用于压缩和解压文件的程序。它提供了对 lzma 和更新的 xz 压缩格式的支持。使用 xz 压缩文本文件能比传统的 gzip 或 bzip2 命令有更高的压缩比。 提醒$LFS/tools 目录可以在 LFS 系统构建完成后删除，但仍然可以保留下来用于构建额外的相同版本 LFS 系统。备份 $LFS/tools 目录到底有多少好处取决于你个人如果你想保留临时工具用来构建新的 LFS 系统，现在就要备份好。本书随后第六章中的指令将对当前的工具做些调整，导致在构建新系统时会失效 到此,准备工作完成]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-07-13 lfs编译日志]]></title>
    <url>%2F2018%2F07%2F13%2F2018-07-13%2F</url>
    <content type="text"><![CDATA[lfs准备工作已经全部完成 已经把编译的工作做完了 现在准备在写md文档总结一下(时间估计两天时间) 说实话,编译的工作是真的费时间]]></content>
      <categories>
        <category>lfs编译日志</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux From Scrach Pass 1]]></title>
    <url>%2F2018%2F07%2F12%2Flfs1%2F</url>
    <content type="text"><![CDATA[准备准备空间大概8g 准备在u盘上构建系统我准备将u盘对半分成两个盘一个安装系统,就用ext4一个当作普通的u盘来用记得分区的时候格式化可以使用fdisk 或者 其他工具 另外: 我的arch上没有创建swap分区 挂载U盘/移动硬盘使用fdisk -l命令得到123456789Disk /dev/sdb：29 GiB，31104958464 字节，60751872 个扇区单元：扇区 / 1 * 512 = 512 字节扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：dos磁盘标识符：0xcad4ebea设备 启动 起点 末尾 扇区 大小 Id 类型/dev/sdb4 * 63 60751871 60751809 29G c W95 FAT32 (LBA) 创建文件夹 将sdb4挂载到文件夹上 一般u盘会自动挂载,像我的系统就是挂载到run/s/xxx 下面不过官方建议还是挂载到 /mnt/lfs 下面 mount -v -t ext4 /dev/&lt;xxx&gt; $LFS # 将 /dev/ 挂载到 $LFS 如果重启设备，可能进入后发现 /mnt/lfs 目录下没有内容，这是只需要再次挂载 /dev/ 到 /mnt/lfs。 此处 用实际的设备名称代替 这里我只使用一个 / 分区 如果 LFS 使用了多个分区，(比如：一个 /，一个 /usr)，用下面的命令挂载它们： 1234mkdir -pv $LFS # 建立 / 分区的挂载点mount -v -t ext4 /dev/&lt;xxx&gt; $LFS # 将 /dev/&lt;xxx&gt; 挂载到 $LFSmkdir -v $LFS/usr # 建立 $LFS/usr 挂载点，用于挂载 /usrmount -v -t ext4 /dev/&lt;yyy&gt; $LFS/usr # 将 /dev/&lt;yyy&gt; 挂载到 $LFS/usr 附:如果你正在使用交换分区，用 swapon 命令确保它已经启用。 /sbin/swapon -v /dev/&lt;zzz&gt;用 swap 分区的名字替换。 注意:确保你的 echo $LFS 在root与用户帐号上时/mnt/lfs 你可以使用全局变量来设置 软件包和补丁mkdir -v $LFS/sources在$lfs里创建sources文件夹 来存放 下载好的软件包和补丁 设置目录的写权限和粘滞模式。“粘滞模式”意思是就算有多个用户对某个目录有写权限，仍然只有该文件的主人能删除一个粘滞目录里的文件。下面的命令可以打开写权限和粘滞模式：chmod -v a+wt $LFS/sources 下载软件包可以去中科院镜像里面去下载里面已经有了md5sums 解压放到source里面就行下载完成后使用md5sums检验====&gt;将下载的md5sums 放到sources目录下 123pushd $LFS/sourcesmd5sum -c md5sumspopd 最后的准备工作 我们还需要为构建临时系统做一些额外的准备工作。我们会在 $LFS 中新建一个文件夹用于临时工具的安装，增加一个非特权用户用于降低风险，并为该用户创建合适的构建环境。我们也会解释用于测量构建 LFS 软件包花费时间的单位，或者称为“标准编译单位（SBU）”，并给出一些关于软件包测试套件的信息 以 root 用户运行以下的命令来创建需要的文件夹：mkdir -v $LFS/tools 下一步是在宿主系统中创建 /tools 的符号链接，将其指向 LFS 分区中新建的文件夹。同样以 root 用户运行下面的命令： ln -sv $LFS/tools / 添加 LFS 用户当以 root 用户登录时，犯一个小错误可能会破坏或摧毁整个系统。因此，我们建议在本章中以非特权用户编译软件包。你可以使用你自己的用户名，但要容易的话，就建立一个干净的工作环境，创建一个名为 lfs 的新用户作为新组（名字也是 lfs ）的成员，并在安装过程中使用这个用户。以 root 用户运行以下命令来添加新用户：12groupadd lfsuseradd -s /bin/bash -g lfs -m -k /dev/null lfs 12345678910111213命令行选项的意思：-s /bin/bash把 bash 设置为 lfs 用户的默认 shell。-g lfs这个选项将用户 lfs 添加到组 lfs 中。-m为 lfs 用户创建主目录。-k /dev/null这个参数通过改变输入位置为特殊的空（null）设备，以防止可能从一个模版目录中（默认是 /etc/skel）复制文件。 lfs这是创建的组和用户的实际名称。 要以 lfs 用户身份登录（以 root 身份登录切换到 lfs 用户时不要求 lfs 用户设置了密码），需要给 lfs 用户一个密码：passwd lfs 通过更改文件夹所有者为 lfs，为用户 lfs 赋予了访问 $LFS/tools 文件夹的所有权限： chown -v lfs $LFS/tools 如果正如建议的一样创建了一个单独的工作目录，给 lfs 用户赋予这个文件夹的所有权：chown -v lfs $LFS/sources 下一步，以 lfs 用户身份登录。可以能通过一个虚拟控制台、显示控制器，或者下面的切换用户命令完成：su - lfs 设置环境123cat &gt; ~/.bash_profile &lt;&lt; &quot;EOF&quot;exec env -i HOME=$HOME TERM=$TERM PS1=&apos;\u:\w\$ &apos; /bin/bashEOF 当以 lfs 用户身份登录时，初始 shell 通常是一个可登录的 shell，它先读取宿主机的 /etc/profile文件（很可能包括一些设置和环境变量），然后是 .bash_profile 文件。.bash_profile 文件中的exec env -i.../bin/bash 命令用一个除了 HOME、TERM和 PS1 变量，完全空环境的 shell 代替运行中的 shell。这可以确保没有不必要的或者有潜在风险的环境变量从宿主机系统中泄露到构建环境。这里使用的技巧是为了有一个干净环境。 新的 shell 实例是一个非登录 shell，不会读取 /etc/profile 或者 .bash_profile文件，而是读取 .bashrc文件。 现在创建 .bashrc 文件：123456789cat &gt; ~/.bashrc &lt;&lt; &quot;EOF&quot;set +humask 022LFS=/mnt/lfsLC_ALL=POSIXLFS_TGT=$(uname -m)-lfs-linux-gnuPATH=/tools/bin:/bin:/usr/binexport LFS LC_ALL LFS_TGT PATHEOF set +h命令关闭了 bash的哈希功能。 哈希通常是一个有用的功能，bash 用一个哈希表来记录可执行文件的完整路径，以避免搜索PATH 的时间和又找到一个相同的可执行文件。然而，新工具要一安装后就使用。通过关闭哈希功能，一个程序准备运行时 shell 总是会搜索PATH变量。如此，shell 能在新编译的工具可用时马上在文件夹 $LFS/tools 中找到，而不是记录相同程序在其它地方的之前版本。 设置用户文件新建掩码（umask）为 022，确保新建的文件和目录只有它们自己的所有者可写，任何人都可读和可执行(假定open(2) 系统调用使用的默认模式是新文件使用 644模式，文件夹使用755模式)。 LFS 变量应该设置为选定的挂载点。 LC_ALL 变量控制特定程序的本地化，使得它们的消息能遵循特定国家的惯例。设置 LC_ALL 为 “POSIX” 或 “C”（两者是等价的），确保 chroot 环境中一切如期望的那样进行。 当编译我们的交叉编译器和链接器以及交叉编译我们的临时工具链时，LFS_TGT变量设置了一个非默认，但兼容的机器说明。5.2,“工具链技术说明”包含更多的信息。 把 /tools/bin 放在标准的 PATH 变量前面， 第五章中安装的软件一安装完成 shell 就可使用。这和关闭哈希功能一起，降低了在第五章环境中新程序可用时宿主机器使用旧程序的风险。 生效配置文件:source ~/.bash_profile 关于 SBUSBU 衡量方式如下。我们以第五章编译的第一个软件包 Binutils 所用时间作为一个标准编译单位（SBU），其它软件的生成时间都以其为标准进行比较。 例如，假如编译一个软件耗时 4.5 SBU，而编译安装初代 Binutils 用时 10 分钟的话，那么编译这个软件包大约耗时 45 分钟。当然啦，对于大多数人来说，编译 Binutils 可用不了 10 分钟那么久。 在一些情况下，使用多处理器同时编译可能失败，分析错误日志变得异常困难：因为不同处理器之间的执行路线是交错的。如果你在编译的时候遇到问题，那么请回过来使用单处理器编译，以正确地查看错误消息。 构建临时系统目标是生成一个临时的系统，它包含一个已知的较好工具集，该工具集可与宿主系统分离。通过使用 chroot，其余各章中的命令将被包含在此环境中，以保证目标 LFS 系统能够洁净且无故障地生成。该构建过程的设计就是为了使得新读者有最少的风险，同时还能有最好的指导价值。 最后确认一次是否正确设置了 LFS 环境变量：echo $LFS确认输出显示的是 LFS 分区挂载点的路径，在我们的例子中也就是 /mnt/lfs。 最后，必须强调两个重要的点： [重要] 重要 编译指南假定你已经正确地设置了宿主系统需求和符号链接： shell使用的是 bash。 sh 是到 bash的符号链接。 /usr/bin/awk 是到 gawk的符号链接。 /usr/bin/yacc 是到bison的符号链接或者一个执行 bison 的小脚本。 [重要] 重要 再次强调构建过程： 把所有源文件和补丁放到 chroot 环境可访问的目录，例如 /mnt/lfs/sources/。但是千万不能把源文件放在 /mnt/lfs/tools/ 中。 进入到源文件目录。 对于每个软件包: 用 tar 程序解压要编译的软件包。在第五章中，确保解压软件包时你使用的是 lfs 用户。2. 进入到解压后创建的目录中。4. 根据指南说明编译软件包。6. 回退到源文件目录。8. 除非特别说明，删除解压出来的目录和所有编译过程中生成的 &lt;package>-build 目录。 这里我在使用lfs帐号进入lfs文件夹的时候出现了权限不足,我使用了chmod加了权限 之后就是漫长的编译过程具体按照官方资料上进行编译注意在编译过程中必须清楚知道当前步骤 make 与 make install 防止错误 ====&gt;之后的构建过程 之后补充上 资料(建议配合使用)中文资料(已过期7.7,但翻译还是可以用)https://linux.cn/lfs/LFS-BOOK-7.7-systemd/index.html 英文资料(目前是8.2)http://www.linuxfromscratch.org/lfs/view/stable/index.html]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git443错误]]></title>
    <url>%2F2018%2F07%2F11%2Fgit443%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[在git push的时候出现OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 网上的解决方法都不管用 解决方法: 换网络,连上手机热点,成功 =.=]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>443错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git上传脚本]]></title>
    <url>%2F2018%2F07%2F11%2Fgit%E4%B8%8A%E4%BC%A0%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[由于上传命令太多了,所以写了脚本命名为comgit12#!/bin/bashgit add --all;git commit -m &quot;$1&quot;;git pull;git push; 使用方法 comgit &quot;comment&quot;]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python脚本基础]]></title>
    <url>%2F2018%2F07%2F10%2Fpython%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数组类型tuple字典类型dict使用*tuple解析数组使用**dict解析字典传参数的时候 单个字符,数字由*args接受,形成tuple键值对有**kwargs接受,形成dict主函数if __name__ == &#39;__main__&#39;当然也可以使用sys.argv来读取参数]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell基础]]></title>
    <url>%2F2018%2F07%2F10%2Fshell%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[shell开头12345#!/bin/bash#!/bin/sh#!/usr/bin/awk#!/usr/bin/env python#!/usr/bin/perl 这几行在第一行,不再第一行就是注释不用的话就用相关解释器带上文件名执行在写脚本的时候如果不加前面的也会交给bash解释,但是还是指定解释器比较好 注意点一定义变量名的时候等号旁边没有空格 要在登录后显示初始化内容可以将脚本文件放到 /etc/profile.d/ 的下面或者是更改/etc/motd 文件 单引号中`` 命令无效 当参数大于9个要使用${}方式 touch 主要是用来更新时间的…. 使用cat连接两个文件 ln -s 源文件 快捷方式 s表示链接 有多个命令就使用;号,若将输出全都重定向用{}扩起来,{}是父shell,()是子shell 注意点二12345678read读到换行符为止,所以就使用循环可以将文件读完,不然好像只能读一行黑洞/dev/null 了解一下-.-cp mv rm 加上-i 进行确认`command` == $(command)`read file` 是要求用户输入并且保存到file变量中...`read -p &quot;&quot; ver `就像scanf一样..(我下所的)readonly xxx=1 或者readonly xxx(已定义) 表示只读无法改变包括unset用重定向代替输入 shell中0给了stdin 1给了stdout 2给了stderr 其余数字可以来关联输出文件 例如文件中&gt;&amp;3 命令用3&gt;文件 输出到文件中 exec 将文件关联paste两个文件连接tr替换if空格[] while空格: expand unexpand 将tab 转换成空格 一般只早开头 使用-a 替换全部 unset 消除定义的变量 ${array[*]} == ${array[@]} “”${array[*]} != “${array[@]}”前面是整个数组的字符串,后面时整个数组 123456789条件语句if or elif 后面要跟上 then 如:if [ xx ]then xxxxxelif [ xxx ]then xxxxxfi 12345678[ ]是shell的内置命令 下列给出操作符:-eq equal to-ne not equal to-lt less than-gt great thange (没有-哦) great or equal如果条件判断与then写在统一行then前面加;[]两侧要有空格 注意点三 在case中 中止case语句用;;如果用;&amp; or ;;&amp;来终止还是执行下去,他中止的是子句,会使用word在去匹配pattern,直到遇到;;结束case递增可以使用let x=$x+1 当然也可以使用expr语句-.-我也是随机选择的….do 和while [ ]写在一起的时候do前面有分号while 后面可以加上命令list 使用分号;来隔开,决定是否推出循环的是最后一个命令返回值,注意是最后一个!!!其中命令都是用[]扩起来的列入[];[];[][] 是条件-n String 判断字符串长度是否非0-z Stirng 判断字符串长度为0时就断(zero)String=StringString!=String 1234567for 后面不加in就选择传入的参数同时也可以写的像c的for一样但是写成要这样for((p=1,k=321;p&lt;10;p++,k++))do xxxxxdone 1234select var in xxx xxx xxx xxxdo xxxx(可以是case或者是if条件判断)done 在select中要写退出循环的条件,不然会一直循环下去,还有就是要写其他选项的条件,不然不科学-.- option 参数的代码123456while getopts x:x:x: OPTION 这个option可以随便定义do case $OPTION in x) xxx=$OPTAGE;; 这个变量时规定的 与$REPLY一样done 写的函数可以直接调用 条件中-r 可读 -w 可写 -a and12345$&#123;xx:-dsa&#125;等:(也可以通过其他方式来实现) :-先默认后赋值,不改变 :+先赋值,不改变 :=改变 :?若是空的则输出错误退出脚本 $PAGER 似乎是系统变量 显示文档的less也可以通过其他方式来实现 echo -n 不换行输出 -e 激活转移字符 sort -u 忽略相同行 当不能使用管道时可以使用命令替代参数 数字或者字符串expression不能出现在$()中,要用()扩起来后在放到$()中间…… 循环的话要注意变量的赋值 find 命令 从给定的文件位置开始找 -iname 忽略大小写-mtime 表示修改时间 -mtime n修改时间为n天-mtime +n 大于n天-mtime -n 小于n天 如果有多个命令使用-a来连接 其中如果有()要使用\ 来转义 -o 或者 xargs 可以处理很多参数 locate 查询本地的数据库 find是直接查找文件系统 dd if=file of=file count=blocks bs=bytes 信号 通过trap xx(函数名) 数字 可以将让函数才该信号出现的时候调用该函数使用trap也可以脚本结束后调用函数,数字是0使用’’ 或者: 是屏蔽中断INT信号使用trap INT 来恢复exit xx 中xx是信号kill 进程的时候要先kill掉子进程,不然会交给init进程接管使用&amp;&amp;连接多个命令的时候是一个一个执行的,会创建子bash执行进程 command|sed &#39;command&#39;sed &#39;command&#39; file 使用;分号来连接多个command(不用另起’’) 或者使用-e(要’’分离每个命令)也可以将多个command写在一个文件中,-f指定文件!可以对取值范围取反sed stream editor 可以从管道或者文件中读取参数 sed -n &#39;1~2p&#39; 1 start 2 step sed还能加上正则/^$/使用正则还能代替行号使用&amp;表示正则表达式获取的结果 awk ‘script’ files12345678910&apos;script&apos; 中一般为 /pattern/&#123;action&#125; exprssion &#123;action&#125;其中特殊的有: value ~ /pattern/ 与正则匹配 加个!就是不匹配 可以使用()将判断分离,这样()间可以使用||或者&amp;&amp;链接分割符通过-F指定可以在awk文件中写好命令之后使用-f来指定文件使用BEGIN&#123;&#125;来执行处理数据之前执行的初始化操作使用next来表示 将两个命令的结果连接起来 #!/bin/bash/awk -f awk脚本 .awk awk中有内建变量 NR为行数 FS分割符 等等]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim基础]]></title>
    <url>%2F2018%2F07%2F10%2Fvim%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[ctrl + s 卡死后使用 ctrl + q z回车 将光标所在行移动到屏幕顶端 z. 将光标所在行移动到屏幕中间 z- 将光标所在行移动到屏幕低端]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql基本知识]]></title>
    <url>%2F2018%2F07%2F10%2Fsql%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[当我在将大小写忽略的时候之前使用大写的数据库的名字就进不去了,因为系统自动将我打的大写换成了小写….. 每一个检查点都会记录他自己的操作对象的信息状态,当共用的是同一个硬盘上的数据,硬盘上的数据是会被最近的检查点所覆盖掉的,当要回复在之前的某一个特定的检查点的时候,是先通过最近的检查点来逐级向上恢复的]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基本操作]]></title>
    <url>%2F2018%2F07%2F10%2Fgit%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[一般提交操作为:1234git add -all ==&gt; gaagit commit -m &quot;xxxx&quot; ==&gt; gcgit pull ==&gt; glgit push ==&gt; gp 自动保存密码:git config --global credential.helper store]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css渐变动画]]></title>
    <url>%2F2018%2F07%2F10%2Fcss%E6%B8%90%E5%8F%98%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[鼠标放上去渐变12345678div&#123;width:100px;transition: width 2s;-moz-transition: width 2s; /* Firefox 4 */-webkit-transition: width 2s; /* Safari 和 Chrome */-o-transition: width 2s; /* Opera */&#125; 使div居中:要设置div的宽度 再使用margin 0 auto设置]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>渐变</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于pacman]]></title>
    <url>%2F2018%2F07%2F10%2Fpacman%2F</url>
    <content type="text"><![CDATA[pacman -D --asexplicite xxx 设置为单独安装的包 pacman -Qtd 出来的包可以删 但有些删除可能会有影响,大多没用 pacman -Rscn 可以删除干净包 pacman -Rdd 是在出现了依赖问题的时候用用,一般就不用它,他是强行破坏 依赖关系 有些依赖关系不一定会长久存在,所以pacman -Qtd不是删除干净包就一定没有东西的 可能会在你装包的时候出现依赖的更新 pacman不会自动帮你删除孤包 Rdd所操作的对象往往是这个包同时被其他的包依赖， 如果你正常情况下用R去卸它是会报错提示破坏依赖的。 比如一条依赖树a-b-c，即c依赖b，b又依赖a， 那么如果你用R或者Rs去卸载b就会报错提示你c的依赖将被破坏所以不能卸。 如果是用Rdd卸载b就是不管谁依赖它就是强行把b一个东西删掉， 本质上是临时破坏一下依赖。这个做法往往是出了什么问题才会用的。 卸载同时删配置文件的参数是-n，-c的意思是同时把依赖它的包也卸载掉 总结一下 对于a-b-c这样一条依赖树且a和b都是作为依赖安装的， 那么如果使用-R、-Rs去卸载b就会报错提示c的依赖被破坏并中断操作， 使用-Rdd卸载b就会强行删b，同时a和c被保留。 使用-Rc卸b就会把b和c卸载掉，用-Rsc卸b就会把abc全卸掉]]></content>
      <categories>
        <category>arch</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
